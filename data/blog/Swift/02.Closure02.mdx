---
title: '🍎 Swift - 클로저(Closure).02'
date: '2022-03-02'
tags: ['Swift']
draft: false
summary: 'Trailing 클로저에 대해 알아봅시다.'
---

이번에는 덩치가 큰 클로저라는 친구를 다이어트 시키는 방법과 저를 곤란하게 만든 @escaping 클로저에 대해 알아보겠습니다

우리 클로저라는 친구는 덩치가 너무 큽니다.. 이전 게시물의 예시를 다시 가져와볼까요?

```swift
foo(closure: { () -> () in
  print("Hi! I'm Closure")
})
```

클로저를 인수로 받는 함수의 호출법입니다. 위 예시는 사실 아주 단순한 친구였죠?

```swift
foo(closure)
```

네.. 가만히 한번 관찰해보면 이 친구는

`() -> ()`

요 부분이라던지..

`closure:`

요 부분이라던지.. 불필요하게 명시되어 있는 여러 부분들이 보입니다. 마치 저의 몸에 붙어있는 불필요한 지방같죠. 😝

그래서 지금부터는 클로저의 체중 감량법을 알아보겠습니다.

---

## Trailing Closure (트레일링 클로저)

또 새로운 용어가 나왔지만 이해를 돕기 위한 도구로서 접근해봅시다. “Trailing = 끝에 붙은” 이라는 뜻이죠?

이 경량법은 **함수의 마지막 인자로 클로저**가 들어가있을 때 사용할 수 있습니다. 마지막 클로저를 빼내서 **함수의 끝**에 간략화해서 붙여쓰는 방법이죠. 이 때, 인자의 자리에서 뛰쳐나왔으니 **인자명은 적지 않습니다.**

역시 예시가 이해에 직빵이죠?

```swift
foo(closure: { () -> () in
    print("Hi! I'm Closure")
})
```

네 위의 예시와 같은 예시입니다. `function({ … })` 이렇게 괄호안에 중괄호가 들어가있어서 한 눈에 파악이 어려운 점이 있었습니다. 그래서 **Trailing Closure**를 사용해볼게요!

```swift
foo() { () -> () in
  print("Hi! I'm Closure")
}
```

이렇게!! `function() { … }` 형태로 바꿀 수 있고, `closure:` 와 같은 인자명도 생략할 수 있습니다.

그리고 여기에서 추가로! 인자가 클로저 단 하나일 경우에는 `()`까지 생략 가능합니다.

```swift
foo { () -> () in
  print("Hi! I'm Closure")
}
```

이렇게 말이죠!

인자가 여러개인 경우도 한번 볼게요.

```swift
func fetchData(success: () -> (), fail: () -> ()) {
  // Tasks
}
```

위 함수는 아래와 같이 호출될겁니다.

```swift
fetchData(success: { () -> () in
  print("Success")
}, fail: { () -> () in
  print("Fail")
})
```

이 호출법에 Trailing Closure를 활용해볼게요.

```swift
fetchData(success: { () -> () in
  print("Success")
}) { () -> () in
  print("Fail")
}
```

이렇게! 마지막 클로저 인자만 뒤로 쏙 뺄 수 있죠.

정리해볼까요?

1. 마지막 인자가 클로저인 경우, 해당 클로저를 인자에서 빼내서 함수 뒤에 붙일 수 있다.
2. 이 때, 인자명은 생략된다.
3. 만약 인자가 클로저 단 하나일 경우에는 함수 호출 구문인 () 또한 생략할 수 있다.

## ( ) -> ( ) in 생략

자.. 그런데 사실 저희 눈에 제일 거슬리는건 저런 마이너한 부분이 아닙니다. 본인이 클로저라고 당당히 소리치고 있는 `() -> () in` 이 부분이죠.

너무 자기주장이 강해서 클로저 구문을 보면 저 부분부터 눈이 갑니다. 그래서 저 부분을 생략해볼겁니다.

자 아래와 같은 함수가 있습니다.

```swift
func foo(closure: (Int, Int, Int) -> (Int)) {
  closure(1, 2, 3)
}
```

인자로 Int형 1, 2, 3을 받아 Int형 Return Type을 내보내는 클로저를 인수로 갖는 함수 foo()이네요. 이 함수를 호출할 때는 어떻게 해야할까요?

```swift
foo(closure: {closure: (a: Int, b: Int, c: Int) -> Int in
  return a + b + c
})
```

혹은 Trailing Closure를 사용해서

```swift
foo() { (a: Int, b: Int, c: Int) -> Int in
  return a + b + c
}
```

이런식으로 주저리주저리.. 굉장히 길어집니다. 심지어 위 예시는 굉장히 간단한 예시이죠? 실전에선 더욱 복잡해지고 길어질겁니다. 그래서 이 친구를 총 다섯 단계에 걸쳐 축약해볼게요!

### 1. 데이터 타입을 생략한다.

가장 만만한 데이터 타입부터 생략해봅시다. Swift는 현대 언어의 기본 소양인 “데이터타입 알아서 처리하기” 기능이 당연히 있습니다. 이를 적극적으로 활용한 방법이죠.

```swift
foo(closure: {closure: (a: Int, b: Int, c: Int) -> Int in
  return a + b + c
})
```

여기서 Int 타입들을 전부 생략합니다!

```swift
foo(closure: {closure: (a, b, c) in 
  return a + b + c
})
```

😮😮😮

벌써부터 엄청나게 줄어들었네요! 물론 데이터타입에 대해 엄격하게 관리하실거면 하나하나 적어주시는게 좋습니다.

### 2. 클로저의 인자명을 생략하고 shortand를 사용한다.

우선 shortand가 무엇이냐 하면,

`($0, $1, $2)`

요 친구들입니다. 파이썬을 다뤄보신 분들이라면 익숙하실거에요. 각각 **(첫 번째 인자, 두 번째 인자, 세 번째 인자)** 를 의미하죠.

이를 위 예시에 한 번 적용해볼까요?

```swift
foo(closure: {closure: (a, b, c) in 
  return a + b + c
})
```

쨔쟈쟌~

```swift
foo(closure: {
  return $0 + $1 + $2
})
```

와우.. 이제 두 번째 단계인데 벌써 엄청나게 단순해졌어요.

물론 두 번째 방법에도 유의할 점은 있습니다. 인덱스 수와 인자의 수를 정확히 맞춰주셔야 해요!

### 3. 클로저 구문 안에 return만 있을 경우, 이 또한 생략한다.

이건 빠르게 예시로 보고 넘어갑시다.

```swift
foo(closure: {
  return $0 + $1 + $2
})
```

이렇게 클로저 안에 return 구문만 있는 경우에는?

```swift
foo(closure: {
  $0 + $1 + $2
})
```

이렇게 `return` 또한 생략해줄 수 있습니다.

### 4. Trailing Closure

위에서 다룬 Trailing Closure를 적용해줍시다.

```swift
foo(closure: {
  $0 + $1 + $2
})
```

마지막 인자를 함수 뒤로 빼버리죠!

```swift
foo() {
  $0 + $1 + $2
}
```

ㅎㅎ;;;

### 5. 인자가 클로저 단 하나라면? ( )도 생략한다.

마찬가지로 위에서 다뤘었죠? 인자가 클로저 단 하나이고, **Trailing Closure**를 적용하면 `()` 안에는 아무것도 남아있지 않습니다.

```swift
foo() {
  $0 + $1 + $2
}
```

없어져라 ( )!

```swift
foo {
  $0 + $1 + $2
}
```

여기까지! 통통했던 클로저 친구가 이쑤시개가 되었습니다.. 드라마틱한 연출을 위해 비교해볼게요.

```swift
foo(closure: {closure: (a: Int, b: Int, c: Int) -> Int in
  return a + b + c
})
```

이 친구가..

```swift
foo {
  $0 + $1 + $2
}
```

이렇게.. 이 정도면 클로저 친구의 건강을 걱정해야 하는거 아닌가 싶네요 😅

물론 위의 예시는 매우 극단적인 경우입니다. 실전에서 이렇게까지 축약되는 경우는 거의 없다고 보셔도 되지만, 한두가지만 적용해도 가시성이 훨씬 좋아지니 적극적으로 활용해줍시다!
